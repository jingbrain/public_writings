# 个人知识付费平台 - 技术建议（Python方案）

根据《网站需求.md》中描述的建站需求，以下是基于Python的开发建议。

---

## 推荐技术栈

### 核心架构

| 层级 | 推荐方案 | 说明 |
|------|---------|------|
| **后端框架** | FastAPI | 高性能异步框架，适合API开发 |
| **前端框架** | Vue.js 3 + Vite | 学习曲线平缓，中文文档完善 |
| **数据库** | PostgreSQL | 稳定可靠，支持JSON字段 |
| **ORM** | SQLAlchemy 2.0 | Python标准ORM，功能强大 |
| **认证** | JWT + OAuth2 | FastAPI内置支持 |
| **缓存** | Redis | 会话管理、内容缓存 |
| **部署** | Docker + Nginx | 便于迁移和扩展 |

### 备选方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **FastAPI + Vue** | 高性能、现代化、前后端分离 | 需要学Vue基础 | 追求性能和长期维护 |
| **Django + DRF** | 生态成熟、管理后台自带 | 相对较重 | 快速开发、功能丰富 |
| **Django + HTMX** | 极简前端、无需学JS框架 | 交互体验有限 | 快速原型、简单交互 |

---

## 详细技术选型

### 后端：FastAPI

```bash
# 核心依赖
pip install fastapi uvicorn sqlalchemy asyncpg
pip install python-jose passlib python-multipart
pip install redis aiohttp
```

**项目结构**：
```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI入口
│   ├── config.py            # 配置（从环境变量读取）
│   ├── database.py          # 数据库连接
│   ├── models/              # SQLAlchemy模型
│   │   ├── user.py
│   │   └── article.py
│   ├── schemas/             # Pydantic数据模型
│   ├── routers/             # API路由
│   │   ├── auth.py          # 登录注册
│   │   ├── articles.py      # 文章API
│   │   └── users.py         # 用户API
│   ├── services/            # 业务逻辑
│   │   ├── wechat_oauth.py  # 微信登录
│   │   └── payment.py       # 支付处理
│   └── utils/               # 工具函数
├── requirements.txt
├── Dockerfile
└── .env                     # 环境变量（数据库配置等）
```

### 前端：Vue.js 3

```bash
# 创建项目
npm create vite@latest frontend -- --template vue
cd frontend
npm install vue-router pinia axios
npm install @vueuse/core marked    # 工具库和Markdown渲染
```

**项目结构**：
```
frontend/
├── src/
│   ├── main.js
│   ├── App.vue
│   ├── views/               # 页面组件
│   │   ├── Home.vue
│   │   ├── Article.vue
│   │   └── Login.vue
│   ├── components/          # 通用组件
│   │   ├── ArticleCard.vue
│   │   └── PaywallBlock.vue # 付费墙组件
│   ├── stores/              # Pinia状态管理
│   │   └── user.js          # 用户状态
│   ├── api/                 # API调用
│   └── assets/              # 静态资源
├── index.html
└── vite.config.js
```

---

## 权限系统设计

### 用户等级定义

```python
# app/models/user.py
from enum import IntEnum

class UserLevel(IntEnum):
    ANONYMOUS = 0       # 未登录访客
    REGISTERED = 1      # 登录的非会员
    PREMIUM = 2         # 付费Premium会员
    PREMIUM_PLUS = 3    # 付费Premium Plus会员
```

### 数据库模型（SQLAlchemy）

```python
# app/models/user.py
from sqlalchemy import Column, Integer, String, DateTime, Enum
from app.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    email = Column(String(255), unique=True, nullable=True)
    wechat_openid = Column(String(255), unique=True, nullable=True)
    nickname = Column(String(100))
    avatar_url = Column(String(500))
    level = Column(Integer, default=UserLevel.REGISTERED)
    premium_expires_at = Column(DateTime, nullable=True)  # 会员到期时间
    created_at = Column(DateTime)
    updated_at = Column(DateTime)
```

```python
# app/models/article.py
from sqlalchemy import Column, Integer, String, Text, DateTime, JSON
from app.database import Base

class Article(Base):
    __tablename__ = "articles"
    
    id = Column(Integer, primary_key=True)
    title = Column(String(500))
    slug = Column(String(200), unique=True)
    tags = Column(JSON)  # ["博叔知识分享", "Python教程"]
    
    # 分段内容，按权限等级存储
    content_free = Column(Text)           # 所有人可见
    content_registered = Column(Text)     # 登录后可见
    content_premium = Column(Text)        # Premium可见
    content_premium_plus = Column(Text)   # Premium Plus可见
    
    created_at = Column(DateTime)
    updated_at = Column(DateTime)
```

### 文章内容API

```python
# app/routers/articles.py
from fastapi import APIRouter, Depends
from app.models.user import UserLevel
from app.services.auth import get_current_user_optional

router = APIRouter()

@router.get("/articles/{slug}")
async def get_article(slug: str, user = Depends(get_current_user_optional)):
    article = await get_article_by_slug(slug)
    user_level = user.level if user else UserLevel.ANONYMOUS
    
    # 根据用户等级组装可见内容
    content_parts = [article.content_free]
    
    if user_level >= UserLevel.REGISTERED and article.content_registered:
        content_parts.append(article.content_registered)
    
    if user_level >= UserLevel.PREMIUM and article.content_premium:
        content_parts.append(article.content_premium)
    
    if user_level >= UserLevel.PREMIUM_PLUS and article.content_premium_plus:
        content_parts.append(article.content_premium_plus)
    
    # 返回时标记是否有更多内容需要升级才能查看
    return {
        "title": article.title,
        "content": "\n\n".join(content_parts),
        "has_more_content": user_level < UserLevel.PREMIUM_PLUS and (
            article.content_registered or 
            article.content_premium or 
            article.content_premium_plus
        ),
        "required_level_for_more": get_next_required_level(article, user_level)
    }
```

---

## 微信登录实现（Python）

### 微信OAuth流程

```python
# app/services/wechat_oauth.py
import httpx
from app.config import settings

class WeChatOAuth:
    AUTHORIZE_URL = "https://open.weixin.qq.com/connect/qrconnect"
    ACCESS_TOKEN_URL = "https://api.weixin.qq.com/sns/oauth2/access_token"
    USERINFO_URL = "https://api.weixin.qq.com/sns/userinfo"
    
    def __init__(self):
        self.app_id = settings.WECHAT_APP_ID
        self.app_secret = settings.WECHAT_APP_SECRET
        self.redirect_uri = settings.WECHAT_REDIRECT_URI
    
    def get_authorize_url(self, state: str) -> str:
        """生成微信授权登录URL"""
        return (
            f"{self.AUTHORIZE_URL}?"
            f"appid={self.app_id}&"
            f"redirect_uri={self.redirect_uri}&"
            f"response_type=code&"
            f"scope=snsapi_login&"
            f"state={state}#wechat_redirect"
        )
    
    async def get_access_token(self, code: str) -> dict:
        """用code换取access_token"""
        async with httpx.AsyncClient() as client:
            resp = await client.get(
                self.ACCESS_TOKEN_URL,
                params={
                    "appid": self.app_id,
                    "secret": self.app_secret,
                    "code": code,
                    "grant_type": "authorization_code"
                }
            )
            return resp.json()
    
    async def get_user_info(self, access_token: str, openid: str) -> dict:
        """获取用户信息"""
        async with httpx.AsyncClient() as client:
            resp = await client.get(
                self.USERINFO_URL,
                params={
                    "access_token": access_token,
                    "openid": openid
                }
            )
            return resp.json()
```

### 登录API路由

```python
# app/routers/auth.py
from fastapi import APIRouter, HTTPException
from fastapi.responses import RedirectResponse
from app.services.wechat_oauth import WeChatOAuth
from app.services.auth import create_jwt_token

router = APIRouter()
wechat = WeChatOAuth()

@router.get("/auth/wechat/login")
async def wechat_login():
    """重定向到微信授权页面"""
    state = generate_random_state()  # 防CSRF
    url = wechat.get_authorize_url(state)
    return RedirectResponse(url)

@router.get("/auth/wechat/callback")
async def wechat_callback(code: str, state: str):
    """微信授权回调"""
    # 1. 用code换token
    token_data = await wechat.get_access_token(code)
    if "errcode" in token_data:
        raise HTTPException(400, "微信授权失败")
    
    # 2. 获取用户信息
    user_info = await wechat.get_user_info(
        token_data["access_token"],
        token_data["openid"]
    )
    
    # 3. 创建或更新本地用户
    user = await get_or_create_user_by_wechat(
        openid=user_info["openid"],
        nickname=user_info["nickname"],
        avatar=user_info["headimgurl"]
    )
    
    # 4. 生成JWT token，重定向到前端
    jwt_token = create_jwt_token(user.id)
    return RedirectResponse(f"/login/success?token={jwt_token}")
```

### 前置条件
1. 注册[微信开放平台](https://open.weixin.qq.com/)账号
2. 创建网站应用，填写已备案的域名
3. 等待审核通过（通常1-3个工作日）
4. 获取AppID和AppSecret

---

## 数据库独立部署

### 环境变量配置

```python
# app/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # 数据库配置
    DATABASE_HOST: str = "localhost"
    DATABASE_PORT: int = 5432
    DATABASE_NAME: str = "knowledge_platform"
    DATABASE_USER: str = "postgres"
    DATABASE_PASSWORD: str = ""
    
    # 微信配置
    WECHAT_APP_ID: str = ""
    WECHAT_APP_SECRET: str = ""
    WECHAT_REDIRECT_URI: str = ""
    
    # JWT配置
    JWT_SECRET_KEY: str = "your-secret-key"
    JWT_ALGORITHM: str = "HS256"
    
    # Redis配置
    REDIS_URL: str = "redis://localhost:6379"
    
    @property
    def DATABASE_URL(self) -> str:
        return (
            f"postgresql+asyncpg://{self.DATABASE_USER}:{self.DATABASE_PASSWORD}"
            f"@{self.DATABASE_HOST}:{self.DATABASE_PORT}/{self.DATABASE_NAME}"
        )
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### .env 文件示例

```bash
# .env（生产环境）
DATABASE_HOST=your-db-server.com
DATABASE_PORT=5432
DATABASE_NAME=knowledge_platform
DATABASE_USER=app_user
DATABASE_PASSWORD=your_secure_password

WECHAT_APP_ID=wx1234567890
WECHAT_APP_SECRET=your_app_secret
WECHAT_REDIRECT_URI=https://yourdomain.com/auth/wechat/callback

JWT_SECRET_KEY=your-very-long-random-secret-key

REDIS_URL=redis://your-redis-server:6379
```

### 云数据库推荐（国内）
- **阿里云 RDS PostgreSQL** - 稳定可靠，自动备份
- **腾讯云 PostgreSQL** - 与腾讯云服务器配合好
- **华为云 GaussDB** - 华为生态

---

## 部署方案

### 推荐架构

```
                    ┌─────────────┐
                    │   Nginx     │ ← 反向代理 + SSL
                    └──────┬──────┘
                           │
          ┌────────────────┼────────────────┐
          ▼                ▼                ▼
    ┌───────────┐    ┌───────────┐    ┌───────────┐
    │  前端静态  │    │  FastAPI  │    │   Redis   │
    │   (Vue)   │    │   后端    │    │   缓存    │
    └───────────┘    └─────┬─────┘    └───────────┘
                           │
                    ┌──────▼──────┐
                    │ PostgreSQL  │ ← 独立数据库服务器
                    └─────────────┘
```

### Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  backend:
    build: ./backend
    environment:
      - DATABASE_HOST=${DATABASE_HOST}
      - DATABASE_PORT=${DATABASE_PORT}
      - DATABASE_NAME=${DATABASE_NAME}
      - DATABASE_USER=${DATABASE_USER}
      - DATABASE_PASSWORD=${DATABASE_PASSWORD}
    ports:
      - "8000:8000"
    depends_on:
      - redis

  frontend:
    build: ./frontend
    ports:
      - "3000:80"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - backend
      - frontend
```

---

## 开发路线图

### 第一阶段：基础搭建（2-3周）
- [ ] 搭建FastAPI项目骨架
- [ ] 数据库模型设计与迁移
- [ ] 用户注册/登录（邮箱）
- [ ] 基础文章CRUD API
- [ ] Vue前端基础页面

### 第二阶段：核心功能（2-3周）
- [ ] 微信OAuth登录集成
- [ ] 文章权限分级显示
- [ ] 会员等级系统
- [ ] 标签Tag管理

### 第三阶段：支付与运营（2-3周）
- [ ] 支付宝/微信支付集成
- [ ] 会员订阅管理
- [ ] 后台管理界面
- [ ] 数据统计分析

### 第四阶段：优化上线（1-2周）
- [ ] 性能优化（缓存、CDN）
- [ ] 安全加固
- [ ] 域名备案与部署
- [ ] 监控与日志

---

## 学习资源

| 技术 | 推荐资源 |
|------|---------|
| FastAPI | [官方文档](https://fastapi.tiangolo.com/zh/) - 有中文版 |
| Vue.js 3 | [官方教程](https://cn.vuejs.org/tutorial/) - 中文完善 |
| SQLAlchemy | [官方教程](https://docs.sqlalchemy.org/en/20/tutorial/) |
| PostgreSQL | [菜鸟教程](https://www.runoob.com/postgresql/postgresql-tutorial.html) |

---

## 总结

采用 **FastAPI + Vue.js + PostgreSQL** 技术栈：

| 优势 | 说明 |
|------|------|
| 发挥Python优势 | 后端完全用Python，您可以快速上手 |
| 前后端分离 | 符合您的需求，便于独立开发和部署 |
| 高性能 | FastAPI性能接近Node.js，Vue构建后是静态文件 |
| 数据库独立 | 通过环境变量配置，迁移只需改.env文件 |
| 长期可控 | 代码完全自有，不依赖第三方平台 |

前端Vue.js学习曲线平缓，配合中文文档，预计1-2周可以掌握基础。建议从官方教程开始，边学边做。
